# VPN Overlay Configuration
# This file extends the base docker-compose.yml to route Aria2 traffic through a VPN
# Usage: docker-compose -f docker-compose.yml -f docker-compose.vpn.yml up

services:
  # OpenVPN client container
  vpn:
    image: dperson/openvpn-client
    container_name: downloadarr-vpn
    cap_add:
      - net_admin
    security_opt:
      - label:disable
    dns:
      - 1.1.1.1
      - 1.0.0.1
    sysctls:
      - net.ipv4.conf.all.src_valid_mark=1
      - net.ipv6.conf.all.disable_ipv6=1
    volumes:
      - /dev/net:/dev/net:z
      - ./config.ovpn:/vpn/config.ovpn:ro
      - ./credentials.txt:/vpn/credentials.txt:ro
    environment:
      TZ: ${TZ:-UTC}
    entrypoint: ["/sbin/tini", "--", "/usr/bin/openvpn.sh"]
    # Forward Aria2 ports through VPN
    command: '-p "6800" -p "6888" -p "6888;udp" -f ""'
    ports:
      - "6800:6800"  # Aria2 RPC port through VPN
      - "6888:6888"  # Aria2 BT port through VPN
    restart: unless-stopped
    networks:
      - downloadarr
    healthcheck:
      test: |
        sh -c '
          # Check if OpenVPN process is running
          if ! pgrep openvpn > /dev/null; then
            echo "OpenVPN process not running"
            exit 1
          fi

          # Simple connectivity test
          if curl -s --max-time 10 https://api.ipify.org > /dev/null; then
            echo "VPN connected and internet accessible"
            exit 0
          else
            echo "VPN process running but no internet connectivity"
            exit 1
          fi
        '
      interval: 30s
      timeout: 15s
      retries: 3
      start_period: 60s

  # Override API service to connect to VPN-routed Aria2
  api:
    container_name: downloadarr-api-vpn
    environment:
      NODE_ENV: production
      VPN_ENABLED: "true"
      # Connect to Aria2 through VPN container
      ARIA2_HOST: vpn
      ARIA2_PORT: 6800
      ARIA2_SECRET: ${ARIA2_RPC_SECRET:-downloadarr}
      # Keep normal Docker networking for database/redis
      DATABASE_URL: postgresql://downloadarr:${POSTGRES_PASSWORD:-downloadarr}@postgres:5432/downloadarr
      REDIS_HOST: redis
      REDIS_PORT: 6379
      JACKETT_URL: http://jackett:9117
      FLARESOLVERR_URL: http://flaresolverr:8191
      DOWNLOAD_PATH: /app/downloads
      LIBRARY_PATH: /app/library
    volumes:
      - ${DOWNLOAD_PATH}:/app/downloads
      - ${LIBRARY_PATH}:/app/library
      - vpn_ip_share:/tmp/vpn-ip:ro  # Read-only access to VPN IP data
      - ./config:/app/config:ro  # Mount config directory
    # Keep normal networking - don't use network_mode
    networks:
      - downloadarr
    depends_on:
      - vpn
      - postgres
      - redis
      - flaresolverr

  # Override original Aria2 to route through VPN
  aria2:
    container_name: downloadarr-aria2-vpn
    # Use VPN network mode to route all traffic through VPN
    network_mode: "service:vpn"
    ports: !reset []  # Remove direct port exposure
    networks: !reset []  # Remove from normal network
    environment:
      PUID: ${PUID:-1000}
      PGID: ${PGID:-1000}
      UMASK_SET: 022
      RPC_SECRET: ${ARIA2_RPC_SECRET:-downloadarr}
      RPC_PORT: 6800
      LISTEN_PORT: 6888
      DISK_CACHE: 64M
      IPV6_MODE: false
      UPDATE_TRACKERS: true
      CUSTOM_TRACKER_URL: ""
      TZ: ${TZ:-UTC}
    volumes:
      - aria2_config:/config
      - ${DOWNLOAD_PATH}:/downloads
      - vpn_ip_share:/tmp/vpn-ip  # Shared volume for VPN IP
    depends_on:
      - vpn

  # Add a separate service to monitor and write VPN IP
  vpn-ip-monitor:
    image: alpine:latest
    container_name: downloadarr-vpn-ip-monitor
    restart: unless-stopped
    network_mode: "service:vpn"  # Use same VPN connection as Aria2
    volumes:
      - vpn_ip_share:/tmp/vpn-ip  # Shared volume for writing VPN IP
    depends_on:
      - vpn
    command: |
      sh -c '
        # Install curl
        apk add --no-cache curl

        # Create directory if it doesn not exist
        mkdir -p /tmp/vpn-ip

        # Function to get and write external IP
        while true; do
          echo "Checking VPN IP..."

          # Get external IP through VPN
          EXTERNAL_IP=$$(curl -s --max-time 10 https://api.ipify.org 2>/dev/null || curl -s --max-time 10 https://ipinfo.io/ip 2>/dev/null || echo "unknown")

          if [ "$$EXTERNAL_IP" != "unknown" ] && [ -n "$$EXTERNAL_IP" ]; then
            echo "$$EXTERNAL_IP" > /tmp/vpn-ip/external_ip
            echo "$$(date): $$EXTERNAL_IP" > /tmp/vpn-ip/last_update
            echo "VPN IP updated: $$EXTERNAL_IP"
          else
            echo "Failed to get VPN IP"
          fi

          # Update every 60 seconds
          sleep 60
        done
      '

  # Override AriaNG to connect to Aria2 through VPN
  ariang:
    container_name: downloadarr-ariang-vpn
    # AriaNG will connect to Aria2 via the VPN container's exposed port
    # No additional configuration needed as it connects via browser

  # Override frontend configuration
  frontend:
    container_name: downloadarr-frontend-vpn
    environment:
      VITE_API_URL: http://localhost:3001

  # Override other services with VPN-specific container names
  redis:
    container_name: downloadarr-redis-vpn

  postgres:
    container_name: downloadarr-postgres-vpn

  jackett:
    container_name: downloadarr-jackett-vpn
    environment:
      PUID: ${PUID:-1000}
      PGID: ${PGID:-1000}
      TZ: ${TZ:-UTC}
      AUTO_UPDATE: true
      # FlareSolverr configuration
      JACKETT__FLARESOLVERR_URL: http://flaresolverr:8191/
      JACKETT__FLARESOLVERR_MAXTIMEOUT: 60000

  flaresolverr:
    container_name: downloadarr-flaresolverr-vpn

# Additional volumes for VPN setup
volumes:
  vpn_ip_share:  # Shared volume for VPN IP information
